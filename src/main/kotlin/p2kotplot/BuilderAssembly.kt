package p2kotplot

import p2kotplot.KotlinWriter.Companion.BuildFunctionName
import p2kotplot.KotlinWriter.Companion.EnumOriginalName
import p2kotplot.KotlinWriter.Companion.InitFunctionName
import p2kotplot.KotlinWriter.Companion.JsonMapName
import p2kotplot.KotlinWriter.Companion.SingularOfArrayFunctionPrefix
import p2kotplot.ast.*
import p2kotplot.ast.Enum
import p2kotplot.plotlytypes.toTitleCase
import p2kotplot.util.deepMap

data class KotlinApi(
    val builderClasses: List<BuilderClassComponents>,
    val topLevelFunctions: List<BuilderFunctionComponents>,
    val enums: List<Enum>
)

data class BuilderClassComponents(
    val name: String,
    val builderFunctions: List<BuilderFunctionComponents>,


    val arrayFieldNames: List<String>,
    val applyStatements: List<String>,
    val constructorArguments: List<ParameterComponents>

)


data class BuilderFunctionComponents(
    val name: String,
    val parameters: List<ParameterComponents>,
    val body: String,
    /**```
     * fun something(init) {
     *    [builderNameOfConstructedType -->] someBuilder    ().apply(init).build()
     * }
     * ```
     * Null means nothing is constructed, so we just use the accepted primitive value as-is
     * (this happens when adding a singular of a primitive type to an array)
     */
    val builderNameOfConstructedType: String?,
    val hasInitParam: Boolean
)


data class ParameterComponents(
    val name: String,
    val type: String,
    val isOptional: Boolean,
    val documentation: String
)

fun applyStatementString(
    variableIsOptional: Boolean,
    isForArray: Boolean,
    variableName: String,
    /**
     * Does not matter when isForArray = true
     */
    variableIsAny: Boolean,
    /**
     * Does not matter when isForArray = true
     */
    variableIsEnum: Boolean
): String {
    if (isForArray) {
        val isEmptyCheck = if (variableIsOptional) "if($variableName.isNotEmpty())" else ""
        return "$isEmptyCheck $JsonMapName[\"$variableName\"] = JsonArray($variableName)"
    } else {
        val nullCheck = if (variableIsOptional) "if($variableName != null)" else ""
        val assignedValue = when {
            variableIsAny -> """ when ($variableName) {
                    is String -> JsonLiteral($variableName)
                    is Number -> JsonLiteral($variableName)
                    is Boolean -> JsonLiteral($variableName)
                    else -> error("unexpected")
                }"""
            variableIsEnum -> "JsonLiteral($variableName.$EnumOriginalName)"
            else -> "JsonLiteral($variableName)"
        }
        return "$nullCheck $JsonMapName[\"$variableName\"] = $assignedValue"
    }
}

class BuilderAssembly(val builder: PublicFlatBuilderRepresentation) {

    fun assembleAll(): KotlinApi {
        val initialTopLevelFunctions = builder.builderFunctions.filter { it.inClass == TopLevel }
//        // Also add other functions that have the same name as initial top level functions.
//        // Those are usually generated by union types and need to be added here.
//        val topLevelFunctions = initialTopLevelFunctions + builder.builderFunctions.filter { builderFunction ->
//            builderFunction !in initialTopLevelFunctions && initialTopLevelFunctions.any { it.name == builderFunction.name }
//        }


        val assembledTopLevelFunctions = assemble(initialTopLevelFunctions)

        val assembledBuilderClasses = builder.builderClasses.map { assemble(it) }

        return KotlinApi(
            builderClasses = assembledBuilderClasses,
            enums = builder.enums,
            topLevelFunctions = assembledTopLevelFunctions
        )
    }

    private fun assemble(builderFunctions: List<BuilderFunction>) = builderFunctions.flatMap {
        assemble(it)
    }

    // Group by name to handle overloads


    private fun assemble(builderClass: BuilderClass): BuilderClassComponents {
        val name = builderClass.name

        val builderFunctions = assemble(builderClass.getBuilderFunctions())

        val arrayFields = builderClass.getBuilderFunctions()
                .filter { it.isForArray }
                .map { it.name }
                .distinct()

        val applyStatements = builderClass.getConstructorArguments().map {
            applyStatementString(
                variableIsOptional = it.optional,
                variableName = it.name,
                isForArray = false,
                variableIsAny = it.type == "Any",
                variableIsEnum = it.isEnumType
            )
        } + builderClass.getBuilderFunctions().filter {
            it.isForArray
        }.map {
            applyStatementString(
                variableIsOptional = it.isOptional,
                variableName = it.name,
                isForArray = true,
                variableIsAny = false, // Does not matter
                variableIsEnum = false // Does not matter
            )
        }.distinct()

        val constructorArguments = builderClass.getConstructorArguments().map {
            it.toParameterComponents()
        }

        return BuilderClassComponents(name, builderFunctions, arrayFields, applyStatements, constructorArguments)
    }

    private fun assemble(builderFunction: BuilderFunction): List<BuilderFunctionComponents> {
        var parametersOfFunction = builderFunction.getOverloadsParameterComponents()
        // When a function has no parameters it leads to the function not existing, so we add one empty overload here.
        if (parametersOfFunction.isEmpty()) parametersOfFunction = listOf(listOf())
        return parametersOfFunction.map { parametersOfOverload ->
            BuilderFunctionComponents(
                name = builderFunction.addOneOfIfNeeded(),
                parameters = parametersOfOverload,
                body = builderFunction.getBody(parametersOfOverload),
                builderNameOfConstructedType = builderFunction.builderNameOfConstructedType,
                hasInitParam = builderFunction.constructsBuilderClass()

            )
        }
    }

    private fun BuilderParameter.toParameterComponents(): ParameterComponents {
        return ParameterComponents(
            name = name,
            type = type,
            isOptional = optional,
            documentation = documentation
        )
    }


    private fun BuilderClass.getConstructorArguments() = builder.parameters.filter {
        it.inConstructorOfClass == name
    }

    private fun BuilderClass.getBuilderFunctions() = builder.builderFunctions.filter {
        it.inClass == name
    }

    /**
     * Returns the list of overloads of a function, each one with the list of parameters it has.
     */
    private fun BuilderFunction.getOverloadsParameters(): List<List<BuilderParameter>> {
        val parametersOfFunction = builder.parameters.filter { parameter ->
            parameter.belongsToFunction == this.name
                    && parameter.inBuilderFunctionInClass == this.builderNameOfConstructedType
        }
        return parametersOfFunction.groupBy { it.overloadNum }.toList().sortedBy { it.first }.map {
            it.second
        }.toList()
    }


    private fun BuilderFunction.getOverloadsParameterComponents(): List<List<ParameterComponents>> =
        getOverloadsParameters().deepMap { it.toParameterComponents() }

    private fun BuilderFunction.addOneOfIfNeeded() = if (isForArray) {
        SingularOfArrayFunctionPrefix + name.toTitleCase()
    } else name


    private fun BuilderFunction.constructsBuilderClass(): Boolean {
//        return this.builderNameOfConstructedType != null
        if (builderNameOfConstructedType == null) return false
        // Checks if the builder class that is constructed in this function has any builder functions.
        val builderFunctions = BuilderClass(this.builderNameOfConstructedType).getBuilderFunctions()
        return builderFunctions.isNotEmpty()
    }


    private fun BuilderFunction.getBody(parametersOfOverload: List<ParameterComponents>): String {

        val objectConstruction = objectConstruction(
            builderNameOfConstructedType = builderNameOfConstructedType,
            parameters = parametersOfOverload,
            withApplyCall = constructsBuilderClass()
        )

        return when {
            // Array
            this.isForArray -> oneOfArrayFunctionBody(objectConstruction, this.name)
            // Top level
            this.inClass == TopLevel -> topLevelFunctionBody(objectConstruction)
            // Data class
            else -> dataClassFunctionBody(objectConstruction, this.name)
        }
    }
}

private fun objectConstruction(
    builderNameOfConstructedType: String?,
    parameters: List<ParameterComponents>,
    withApplyCall: Boolean
): String {
    val builderConstructorParams = parameters.joinToString(", ") { it.name }
    val applyCall = if (withApplyCall) ".apply($InitFunctionName)" else ""
    return if (builderNameOfConstructedType != null) {
        "$builderNameOfConstructedType($builderConstructorParams)$applyCall.$BuildFunctionName()"
    } else {
        // If builderNameOfConstructedType is null we use the parameters as-is
        builderConstructorParams
    }

}

private fun topLevelFunctionBody(objectConstructionString: String) = "return $objectConstructionString"

private fun dataClassFunctionBody(objectConstructionString: String, builderFunctionName: String) =
    "$JsonMapName[\"$builderFunctionName\"] = $objectConstructionString"

private fun oneOfArrayFunctionBody(objectConstructionString: String, arrayName: String) =
    "$arrayName.add($objectConstructionString)"


/******************
For tests mainly
 *******************/
fun topLevelFunctionBody(
    builderNameOfConstructedType: String,
    parameters: List<ParameterComponents>,
    withApplyCall: Boolean
): String = topLevelFunctionBody(objectConstruction(builderNameOfConstructedType, parameters, withApplyCall))

fun dataClassFunctionBody(
    builderNameOfConstructedType: String,
    parameters: List<ParameterComponents>,
    withApplyCall: Boolean,
    builderFunctionName: String
): String = dataClassFunctionBody(
    objectConstruction(builderNameOfConstructedType, parameters, withApplyCall),
    builderFunctionName
)

fun oneOfArrayFunctionBody(
    builderNameOfConstructedType: String?,
    parameters: List<ParameterComponents>,
    withApplyCall: Boolean,
    arrayName: String
): String =
    oneOfArrayFunctionBody(objectConstruction(builderNameOfConstructedType, parameters, withApplyCall), arrayName)